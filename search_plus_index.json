{"./":{"url":"./","title":"项目简介","keywords":"","body":"面试问题集合 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"数据库/索引使用说明&注意事项.html":{"url":"数据库/索引使用说明&注意事项.html","title":"索引使用说明&注意事项","keywords":"","body":"数据库创建索引能够大大提高系统的性能。 通过创建唯一性的索引，可以保证数据库表中每一行数据的唯一性。 可以大大加快数据的检索速度，这也使创建索引的最主要的原因。 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 在使用分组和排序子句进行数据检索时，同样可以显著的减少查询中查询中分组和排序的时间。 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 增加索引也有许多不利的方面。 创建索引和维护索引需要消耗时间，这种时间随着数量的增加而增加。 索引需要占物理空间，除了数据表占据数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要额空间就会更大。 当对表中的数据进行增加，删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 应该对如下的列建立索引 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构。 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度。 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的。 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。 在经常使用在where子句中的列上面创建索引，加快条件的判断速度。 有些列不应该创建索引 在查询中很少使用或者作为参考的列不应该创建索引。 对于那些只有很少数据值的列也不应该增加索引（比如性别，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度）。 对于那些定义为text，image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。 当修改性能远远大于检索性能时，不应该创建索引，因为修改性能和检索性能是矛盾的。 创建索引的方法 直接创建和间接创建（在表中定义主键约束或者唯一性约束时，同时也创建了索引）。 索引的特征 唯一性索引和复合索引。唯一性索引保证在索引列中的全部数据是唯一的，不会包含冗余数据。复合索引就是一个索引创建在两个列或者多个列上。可以减少一在一个表中所创建的索引数量。 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"数据库/InnoDB&MyIsam的区别.html":{"url":"数据库/InnoDB&MyIsam的区别.html","title":"InnoDB&MyIsam的区别","keywords":"","body":" InnoDB支持事物，外键等高级的数据库功能，MyISAM不支持。需要注意的是，InnDB行级锁也不是绝对的，例如mysql执行一个未定范围的sql时，也还是会锁表，例如sql中like的使用 效率，明显MyISAM在插入数据的表现是InnoDB所远远不及的，在删改查，随着InnoDB的优化，差距渐渐变小 行数查询，InnoDB不保存行数，也就是select的时候，要扫描全表，MyISAM只需读取保存的行数即可，这也是MyISAM查询速度快的一个因素。 锁的支持。**MyISAM只支持表锁。InnoDB支持表锁、行锁 行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的 索引，InnoDB会自动创建Auto_Increment类型字段的索引，一般习惯应用于主键，即主键索引（只包含该字段），而MyISAM可以和其他字段创建联合索引。除此之外，MyISAM还支持全文索引（FULLTEXT_INDEX），压缩索引,InnoDB不支持(5.7以后的InnoDB支持全文索引了) 备注：MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。InnoDB存储引擎被完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB存储它的表＆索引在一个表空间中，表空间可以包含数个文件（或原始磁盘分区）。这与MyISAM表不同，比如在MyISAM表中每个表被存在分离的文件中。InnoDB 表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上。 服务器数据备份。InnoDB必须导出SQL来备份，LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，(解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。) 备注：而且MyISAM应对错误编码导致的数据恢复速度快。MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。InnoDB是拷贝数据文件、备份 binlog，或者用 mysqldump，支持灾难恢复（仅需几分钟），MyISAM不支持，遇到数据崩溃，基本上很难恢复，所以要经常进行数据备份。 MyISAM索引结构 MyISAM索引用的B+ tree来储存数据，MyISAM索引的指针指向的是键值的地址，地址存储的是数据。B+Tree的数据域存储的内容为实际数据的地址，也就是说它的索引和实际的数据是分开的，只不过是用索引指向了实际的数据，这种索引就是所谓的(非聚集索引) 因此，过程为： MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，根据data域的值去读取相应数据记录。 InnoDB索引结构 用的也是B+Treee索引结构。Innodb的索引文件本身就是数据文件，即B+Tree的数据域存储的就是实际的数据，这种索引就是(聚集索引)。这个索引的key就是数据表的主键，因此InnoDB表数据文件本身就是主索引。 InnoDB的辅助索引数据域存储的也是相应记录主键的值而不是地址，所以当以辅助索引查找时，会先根据辅助索引找到主键，再根据主键索引找到实际的数据。所以Innodb不建议使用过长的主键，否则会使辅助索引变得过大。 与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。 叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。 建议使用自增的字段作为主键，这样B+Tree的每一个结点都会被顺序的填满，而不会频繁的分裂调整，会有效的提升插入数据的效率。 过程为：将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用”where id = 13”这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。 InnoDB为什么推荐使用自增ID作为主键 自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。 innodb引擎的4大特性 插入缓冲（insert buffer),二次写(double write),自适应哈希索引(ahi),预读(read ahead) 如何选择? 是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM； 如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读也有写，请使用InnoDB。 系统奔溃后，MyISAM恢复起来更困难，能否接受； MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。 为什么使用索引会快? 索引就相当于一本书的目录，通过目录来找书中的某一页，确实是很快的，如果没有目录，就需要一页一页的去翻书了，大大降低了效率 当没有可用的索引时只能走全表扫描,即把主键索引上的叶子节点从头到尾都扫描一遍，然后每扫描到一行把字段 x 的值拿出来再比对一下，筛选出满足条件的记录，这个查询是非常低效的。 当有可以使用索引 x 时,该查询会先到二级索引 x 这个 B+ 树上，快速找到满足要求的叶子节点，而这里的叶子节点上只保存了主键的值，所以还需要通过获得的主键 ID 值再回到主键索引上查出所有字段的值 参考深入理解MySQL索引原理和实现——为什么索引可以加速查询？ window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"数据库/取第一天登录&第二天没有登录的用户.html":{"url":"数据库/取第一天登录&第二天没有登录的用户.html","title":"取第一天登录&第二天没有登录的用户","keywords":"","body":" 在 user_log 表中取出第一天登录第二天没有登录的用户ID id time 1 2019-06-01 1 2019-06-02 2 2019-06-01 3 2019-06-01 3 2019-06-02 4 2019-06-01 select id from user_log u1 where u1.time=\"2019-06-01\" and not exists(select 1 from user_login u2 where u1.id = u2.id and u2.time = '2019-06-02') window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"数据库/Btree&Hash的区别.html":{"url":"数据库/Btree&Hash的区别.html","title":"Btree&Hash的区别","keywords":"","body":" btree与hash索引的适用场景和限制 Mysql索引类型Btree和Hash的区别以及使用场景 MySQL索引类型 btree索引和hash索引的区别 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"数据库/Mysql事物隔离级别.html":{"url":"数据库/Mysql事物隔离级别.html","title":"Mysql事物隔离级别","keywords":"","body":"事务的基本要素 原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。 一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。 隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。 持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。 事务的并发问题 不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据 不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。 幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。 MySQL事务隔离级别 mysql默认的事务隔离级别为 可重复读(repeatable-read) 事务隔离级别 脏读 不可重复读 幻读 读未提交（read-uncommitted） 是 是 是 读已提交（read-committed） 否 是 是 可重复读（repeatable-read） 否 否 是 串行化（serializable） 否 否 否 Mysql锁说明 共享锁(S锁) 用于只读操作(SELECT)，锁定共享的资源。共享锁不会阻止其他用户读，但是阻止其他的用户写和修改。 更新锁(U锁) 用于可更新的资源中。防止当多个会话在读取、锁定以及随后可能进行的资源更新时发生常见形式的死锁。 独占锁(X锁，也叫排他锁) 一次只能有一个独占锁用在一个资源上，并且阻止其他所有的锁包括共享缩。写是独占锁，可以有效的防止“脏读”。 事物隔离实现说明 读未提交 如果一个事务已经开始写数据，则另外一个数据则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。 读已提交 读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。可以通过“瞬间共享读锁”和“排他写锁”实现。 可重复读 读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。可以通过“共享读锁”和“排他写锁”实现。 串行化 读加共享锁，写加排他锁，读写互斥。 参考 MySQL的四种事务隔离级别 面试官：谈谈Mysql事务隔离级别？ mysql/mariadb知识点总结（21）：事务隔离级别 (事务总结之三) window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"数据库/mysql锁机制详解.html":{"url":"数据库/mysql锁机制详解.html","title":"mysql锁机制详解","keywords":"","body":"按锁的粒度划分 表锁：意向锁(IS锁、IX锁)、自增锁； 行锁：记录锁、间隙锁、临键锁、插入意向锁； 共享/排它锁(Shared and Exclusive Locks) 共享锁（Share Locks，记为S锁），读取数据时加S锁 (共享锁之间不互斥，简记为：读读可以并行) 排他锁（eXclusive Locks，记为X锁），修改数据时加X锁 (排他锁与任何锁互斥，简记为：写读，写写不可以并行) 排他锁，一旦写数据的任务没有完成，数据是不能被其他任务读取的，这对并发度有较大的影响。对应到数据库，可以理解为，写事务没有提交，读相关数据的select也会被阻塞，这里的select是指加了锁的，普通的select仍然可以读到数据(快照读)。 意向锁(Intention Locks) InnoDB为了支持多粒度锁机制(multiple granularity locking)，即允许行级锁与表级锁共存，而引入了意向锁(intention locks)。意向锁是指，未来的某个时刻，事务可能要加共享/排它锁了，先提前声明一个意向。 意向锁是一个表级别的锁(table-level locking)； 意向锁又分为： 意向共享锁(intention shared lock, IS)，它预示着，事务有意向对表中的某些行加共享S锁； 意向排它锁(intention exclusive lock, IX)，它预示着，事务有意向对表中的某些行加排它X锁； 记录锁(Record Locks) 记录锁，它封锁索引记录 间隙锁(Gap Locks) 间隙锁的主要目的，就是为了防止其他事务在间隔中插入数据，以导致“不可重复读”。如果把事务的隔离级别降级为读提交(Read Committed, RC)，间隙锁则会自动失效。 间隙锁，它封锁索引记录中的间隔，或者第一条索引记录之前的范围，又或者最后一条索引记录之后的范围 临键锁(Next-key Locks) 临键锁，是记录锁与间隙锁的组合，它的封锁范围，既包含索引记录，又包含索引区间。 默认情况下，innodb使用next-key locks来锁定记录。但当查询的索引含有唯一属性的时候，Next-Key Lock 会进行优化，将其降级为Record Lock，即仅锁住索引本身，不是范围。 插入意向锁(Insert Intention Locks) 对已有数据行的修改与删除，必须加强互斥锁(X锁)，那么对于数据的插入，是否还需要加这么强的锁，来实施互斥呢？插入意向锁，孕育而生。 插入意向锁，是间隙锁(Gap Locks)的一种（所以，也是实施在索引上的），它是专门针对insert操作的。多个事务，在同一个索引，同一个范围区间插入记录时，如果插入的位置不冲突，不会阻塞彼此。 自增锁(Auto-inc Locks) 自增锁是一种特殊的表级别锁（table-level lock），专门针对事务插入AUTO_INCREMENT类型的列。最简单的情况，如果一个事务正在往表中插入记录，所有其他事务的插入必须等待，以便第一个事务插入的行，是连续的主键值。 参考 mysql锁机制详解 MySQL锁机制与用法分析 MySQL InnoDB锁机制全面解析分享 乐观锁与悲观锁——解决并发问题 MySQL学习笔记（四）悲观锁与乐观锁 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"Linux/Crontab表达式详解.html":{"url":"Linux/Crontab表达式详解.html","title":"Crontab表达式详解","keywords":"","body":"图解 特殊字符 特殊字符 代表意义 星号(*) 表示所有可能的值，可以理解为每。 逗号(,) 用逗号隔开的值表示一个列表范围，如1,2,3 每天每小时的第一、第二、第三分钟。 中杠(-) 用中杠隔开的值表示一个数值范围，如1-10 每天每小时的1到10分钟。 正斜线(/) 指定执行任务的间隔频率，如 0 10-18/2 *每天的十点到十八点间隔2小时执行。 实例 # 每分钟执行一次 * * * * * # 每小时的第3和第15分钟执行 3,15 * * * * #在上午的8点到11点的第3和第15分钟执行 3,15 8-11 * * * #在每隔2天的上午8点和11点的第3和第15分钟执行 3,15 8-11 */2 * * #每个星期一的上午8点到11点的第3和第15分钟执行 3,15 8-11 * * 1 #每晚的21：30执行 30 21 * * * #每月1、10、22日的4:30执行 30 4 1,10,22 * * #每周六、日1:10执行 10 1 * * 6,7 #每天18:00到23:00之间每隔30分钟执行 0/30 18-23 * * * #星期六的23:00执行 0 23 * * 6 #每小时执行一次 * */1 * * * #晚上11点到早上7点之间，每小时执行一次 * 23-7/1 * * * #每月的4号与每周一到周三的11点 0 11 4 * 1-3 #一月一号的4点 0 4 1 1 * window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"其他/TCP的三次握手&四次挥手.html":{"url":"其他/TCP的三次握手&四次挥手.html","title":"TCP的三次握手&四次挥手","keywords":"","body":" 第一次握手(SYN=1, seq=x): 客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。 发送完毕后，客户端进入 SYN_SEND 状态。 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1): 服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 - 发送完毕后，服务器端进入 SYN_RCVD 状态。 第三次握手(ACK=1，ACKnum=y+1) 客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1 发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。 第一次挥手(FIN=1，seq=x) 假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。 发送完毕后，客户端进入 FIN_WAIT_1 状态。 第二次挥手(ACK=1，ACKnum=x+1) 服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。 发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。 第三次挥手(FIN=1，seq=y) 服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。 发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。 第四次挥手(ACK=1，ACKnum=y+1) 客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。 服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。 客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"其他/POST&GET区别.html":{"url":"其他/POST&GET区别.html","title":"POST&GET区别","keywords":"","body":"GET - 从指定的资源请求数据。 GET 请求可被缓存 GET 请求保留在浏览器历史记录中 GET 请求可被收藏为书签 GET 请求不应在处理敏感数据时使用 GET 请求有长度限制 GET 请求只应当用于取回数据 GET 只允许 ASCII 字符。 POST - 向指定的资源提交要被处理的数据 POST 请求不会被缓存 POST 请求不会保留在浏览器历史记录中 POST 不能被收藏为书签 POST 请求对数据长度没有要求 POST 数据类型没有限制 对比 区别 GET POST 后退按钮&刷新 无害 数据会被重新提交(浏览器应该告知用户数据会被重新提交) 书签 可收藏为书签 不可收藏为书签 缓存 能被缓存 不能缓存 编码类型 application/x-www-form-urlencoded application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 历史 参数保留在浏览器历史中。 参数不会保存在浏览器历史中。 对数据长度的限制 是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。 无限制。 对数据类型的限制 只允许 ASCII 字符。 没有限制。也允许二进制数据。 安全性 所发送的数据是 URL 的一部分。 数据不会显示在 URL 中 其他 HTTP 请求方法 方法 描述 HEAD 与 GET 相同，但只返回 HTTP 报头，不返回文档主体。 PUT 上传指定的 URI 表示。 DELETE 删除指定资源。 OPTIONS 返回服务器支持的 HTTP 方法。 CONNECT 把请求连接转换到透明的 TCP/IP 通道。 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"其他/Http状态码.html":{"url":"其他/Http状态码.html","title":"Http状态码","keywords":"","body":"1XX ：信息状态码 100 Continue 继续，一般在发送 post 请求时，已发送了 http header 之后服务端 将返回此信息，表示确认，之后发送具体参数信息 2XX ：成功状态码 200 OK 正常返回信息 201 Created 请求成功并且服务器创建了新的资源 202 Accepted 服务器已接受请求，但尚未处理 3XX ：重定向 301 Moved Permanently 请求的网页已永久移动到新位置。 302 Found 临时性重定向。 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI 。 304 Not Modified 自从上次请求后，请求的网页未修改过。 4XX ：客户端错误 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的 内容发起请求。 401 Unauthorized 请求未授权。 403 Forbidden 禁止访问。 404 Not Found 找不到如何与 URI 相匹配的资源。 5XX: 服务器错误 500 Internal Server Error 最常见的服务器端错误。 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 参考列表 状态码 含义 100 客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。 101 服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 　　只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。 102 由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。 200 请求已成功，请求所希望的响应头或数据体将随此响应返回。 201 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 '202 Accepted'。 202 服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 　　返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。 203 服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。 204 服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 　　如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 　　由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。 205 服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 　　与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。 206 服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 　　该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 　　响应必须包含如下的头部域： 　　Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。 　　Date 　　ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。 　　Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 　　假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。 　　假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 　　任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。 207 由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。 300 被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 　　除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 　　如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。 301 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 　　新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 　　注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。 302 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 　　新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 　　注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。 303 对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 　　新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。 304 如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 　　该响应必须包含以下的头信息： 　　Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。 　　ETag 和/或 Content-Location，假如同样的请求本应返回200响应。 　　Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 　　假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。 　　假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。 　　假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。 305 被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 　　注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。 306 在最新版的规范中，306状态码已经不再被使用。 307 请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 　　新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。 　　如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 400 1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 　　2、请求参数有误。 401 当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。 402 该状态码是为了将来可能的需求而预留的。 403 服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。 404 请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。 405 请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 　　鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。 406 请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 　　除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。 407 　与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。 408 请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。 409 由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 　　冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。 410 被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。 　　410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为'410 Gone'，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。 411 服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。 412 服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。 413 服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 　　如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。 414 请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 　　本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 　　重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。 　　客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。 415 对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。 416 如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 　　假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。 417 在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。 421 从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。 422 从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。 422 请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 　　当前资源被锁定。（RFC 4918 WebDAV） 424 由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV） 425 在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。 426 客户端应当切换到TLS/1.0。（RFC 2817） 449 由微软扩展，代表请求应当在执行完适当的操作后进行重试。 500 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。 501 服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。 502 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。 503 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 　　注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。 504 作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 　　注意：某些代理服务器在DNS查询超时时会返回400或者500错误 505 服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。 506 由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。 507 服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918) 509 服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。 510 获取资源所需要的策略并没有没满足。（RFC 2774） window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"PHP/Nginx&PHP通信.html":{"url":"PHP/Nginx&PHP通信.html","title":"Nginx&PHP通信","keywords":"","body":" 理解 Nginx 与 PHP-FPM 通信的工作机制 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"PHP/守护进程的原理与实现.html":{"url":"PHP/守护进程的原理与实现.html","title":"守护进程的原理与实现","keywords":"","body":"在linux或者unix操作系统中在系统的引导的时候会开启很多服务，这些服务就叫做守护进程。为了增加灵活性，root可以选择系统开启的模式，这些模式叫做运行级别，每一种运行级别以一定的方式配置系统。 守护进程是脱离于终端并且在后台运行的进程。守护进程脱离于终端是为了避免进程在执行过程中的信息在任何终端上显示并且进程也不会被任何终端所产生的终端信息所打断。 守护进程及其特性 守 护进程最重要的特性是后台运行。在这一点上DOS下的常驻内存程序TSR与之相似。其次，守护进程必须与其运行前的环境隔离开来。这些环境包括未关闭的文 件描述符，控制终端，会话和进程组，工作目录以及文件创建掩模等。这些环境通常是守护进程从执行它的父进程（特别是shell）中继承下来的。最后，守护 进程的启动方式有其特殊之处。它可以在Linux系统启动时从启动脚本/etc/rc.d中启动，可以由作业规划进程crond启动，还可以由用户终端 （通常是shell）执行。 守护进程流程处理 创建子进程，父进程退出 在子进程中创建新会话 改变当前目录为根目 重设文件权限掩码 关闭文件描述符 守护进程退出处理 PHP参考 0 ) { exit(); } // 在子进程中创建新会话 if( !posix_setsid() ){ exit('setsid error.'); } $pid = pcntl_fork(); if( $pid 0 ) { exit; } // 改变工作目录 chdir( '/tmp' ); // 关闭文件描述符 fclose($fatherFile); C参考 #include #include #include #include #include #include #include #include #define MAXFILE 65535 volatile sig_atomic_t _running = 1; void sigterm_handler(int arg) { _running = 0; } int main() { pid_t pc, pid; int i, fd, len; char *buf = \"this is a Dameon\\n\"; len = strlen(buf); //第一步 pc = fork(); if(pc 0) { exit(0); } //第二步 setsid(); pid = fork();//与终端完全脱离[1] if (pid 0) { exit(0); } //第三步 chdir(\"/\"); //第四步 umask(0); //第五步 for(i = 0;i Linux守护进程的原理与实现 Linux守护进程的编程方法 PHP实现守护进程 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"PHP/Cookie&Session区别.html":{"url":"PHP/Cookie&Session区别.html","title":"Cookie&Session区别","keywords":"","body":"1、存储位置不同 cookie的数据信息存放在客户端浏览器上。 session的数据信息存放在服务器上。 2、存储容量不同 单个cookie保存的数据 对于session来说并没有上限，但出于对服务器端的性能考虑，session内不要存放过多的东西，并且设置session删除机制。 3、存储方式不同 cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据。 session中能够存储任何类型的数据，包括且不限于string，integer，list，map等。 4、隐私策略不同 cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的。 session存储在服务器上，对客户端是透明对，不存在敏感信息泄漏的风险。 5、有效期上不同 开发可以通过设置cookie的属性，达到使cookie长期有效的效果。 session依赖于名为JSESSIONID的cookie，而cookie JSESSIONID的过期时间默认为-1，只需关闭窗口该session就会失效，因而session不能达到长期有效的效果。 6、服务器压力不同 cookie保管在客户端，不占用服务器资源。对于并发用户十分多的网站，cookie是很好的选择。 session是保管在服务器端的，每个用户都会产生一个session。假如并发访问的用户十分多，会产生十分多的session，耗费大量的内存。 7、浏览器支持不同 假如客户端浏览器不支持cookie： cookie是需要客户端浏览器支持的，假如客户端禁用了cookie，或者不支持cookie，则会话跟踪会失效。关于WAP上的应用，常规的cookie就派不上用场了。 运用session需要使用URL地址重写的方式。一切用到session程序的URL都要进行URL地址重写，否则session会话跟踪还会失效。 假如客户端支持cookie： cookie既能够设为本浏览器窗口以及子窗口内有效，也能够设为一切窗口内有效。 session只能在本窗口以及子窗口内有效。 8、跨域支持上不同 cookie支持跨域名访问。 session不支持跨域名访问。 Cookie的工作机制 服务器向客户端响应请求的时候，会在响应头中设置set-cookie的值，其值的格式通常是name = value的格式 浏览器将 cookie 保存下来 每次请求浏览器都会自动将 cookie 发向服务器 cookie最初是在客户端用于存储会话信息的。 Session的工作机制 当客户端第一次请求session对象时，服务器会创建一个session，并通过特殊算法算出一个session的ID，用来标识该session对象，然后将这个session序列放置到set-cookie中发送给浏览器 浏览器下次发请求的时候，这个sessionID会被放置在请求头中，和cookie一起发送回来 服务器再通过内存中保存的sessionID跟cookie中保存的sessionID进行比较，并根据ID在内存中找到之前创建的session对象，提供给请求使用，也就是服务器会通过session保存一个状态记录，浏览器会通过cookie保存状态记录，服务器通过两者的对比实现跟踪状态，这样的做，也极大的避免了cookie被篡改而带来的安全性问题 由于cookie可以被人为的禁止，必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面，附加方式也有两种，一种是作为URL路径的附加信息，另一种是作为查询字符串附加在URL后面 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"PHP/PHP安全处理机制.html":{"url":"PHP/PHP安全处理机制.html","title":"PHP安全处理机制","keywords":"","body":" PHP四大安全策略 php如何做到安全 PHP中MySQL的预处理(预编译)执行方式 php mysql语句预编译（preparestatement） window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"PHP/require&include的区别.html":{"url":"PHP/require&include的区别.html","title":"require&include的区别","keywords":"","body":"处理文件错误的机制上面不同 require() :如果文件不存在，会报出一个fatal error.脚本停止执行; include() : 如果文件不存在，会给出一个 warning，但脚本会继续执行; php性能 对include()来说，在include()执行时文件每次都要进行读取和评估; 对require()来说，文件只处理一次(实际上，文件内容替换了require()语句)。 不同的使用弹性 require的使用方法如 require(\"./inc.php\"); 。通常放在PHP程式的最前面，PHP程式在执行前，就会先读入require所指定引入的档案，使它变成PHP 程式网页的一部份。 include使用方法如 include(\"./inc.php\"); 。一般是放在流程控制的处理区段中。PHP程式网页在读到 include的档案时，才将它读进来。这种方式，可以把程式执行时的流程简单化。 once 带once和不带once的区别主要是:带once的会判断你在加载这个文件之前是否已经加载过了文件，避免重复加载。 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"PHP/PHP翻转数组.html":{"url":"PHP/PHP翻转数组.html","title":"PHP翻转数组","keywords":"","body":" array-reverse array-flip window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"缓存/Redis分布式锁的实现.html":{"url":"缓存/Redis分布式锁的实现.html","title":"Redis分布式锁的实现","keywords":"","body":" 基于redis的分布式锁实现 redis分布式锁实现 Redis分布式锁的实现原理看这篇就够了~ window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"RabbitMQ/消息一致性怎么保证.html":{"url":"RabbitMQ/消息一致性怎么保证.html","title":"消息一致性怎么保证","keywords":"","body":" RabbitMQ数据同步一致性解决方案 四种途径提高RabbitMQ传输数据的可靠性（二） 四种途径提高RabbitMQ传输消息数据的可靠性（一） RabbitMQ如何解决各种情况下丢数据的问题 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"RabbitMQ/RabbitMQ是如何运转的.html":{"url":"RabbitMQ/RabbitMQ是如何运转的.html","title":"RabbitMQ是如何运转的","keywords":"","body":" RabbitMQ是如何运转的？ 认识RabbitMQ交换机模型 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"RabbitMQ/RabbitMQ主从实现原理.html":{"url":"RabbitMQ/RabbitMQ主从实现原理.html","title":"RabbitMQ主从实现原理","keywords":"","body":" 【RabbitMQ】7、RabbitMQ主备复制是异步还是同步？ RabbitMQ集群搭建-镜像模式 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"算法实现/冒泡排序.html":{"url":"算法实现/冒泡排序.html","title":"冒泡排序","keywords":"","body":"$demo_array = array(23,15,43,25,54,2,6,82,11,5,21,32,65); // 第一层for循环可以理解为从数组中键为0开始循环到最后一个 for ($i=0;$i $demo_array[$j]) { $tmp = $demo_array[$i]; // 这里的tmp是临时变量 $demo_array[$i] = $demo_array[$j]; // 第一次更换位置 $demo_array[$j] = $tmp; // 完成位置互换 } } } window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"算法实现/快速排序.html":{"url":"算法实现/快速排序.html","title":"快速排序","keywords":"","body":"function quick_sort($arr){ //先判断是否需要继续进行 $length = count($arr); if($length $arr[$i]) { //放入左边数组 $left_array[] = $arr[$i]; } else { //放入右边 $right_array[] = $arr[$i]; } } //再分别对左边和右边的数组进行相同的排序处理方式递归调用这个函数 $left_array = quick_sort($left_array); $right_array = quick_sort($right_array); //合并 return array_merge($left_array, array($base_num), $right_array);; } window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "}}